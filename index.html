<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Japanese Flashcards (JLPT Vocab API)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f7f9; color: #111; }
    .app { max-width: 920px; margin: 0 auto; padding: 18px; }
    .card { background: #fff; border-radius: 14px; padding: 18px; box-shadow: 0 6px 18px rgba(0,0,0,.08); }
    h1 { margin: 6px 0 16px; font-size: 28px; }
    h2 { margin: 0 0 10px; font-size: 18px; }
    .row { display: flex; gap: 14px; flex-wrap: wrap; align-items: center; }
    label { font-size: 14px; color: #333; }
    input[type="number"], select, input[type="text"] {
      font-size: 14px; padding: 10px 12px; border: 1px solid #d7dbe0; border-radius: 10px;
      background: #fff; outline: none; min-width: 110px;
    }
    input[type="text"] { min-width: 240px; }
    .radio-group { display: flex; gap: 10px; flex-wrap: wrap; }
    .radio-pill {
      display: inline-flex; align-items: center; gap: 8px;
      border: 1px solid #d7dbe0; padding: 8px 10px; border-radius: 999px; background: #fff;
      cursor: pointer; user-select: none;
    }
    .radio-pill input { margin: 0; }
    button {
      border: 0; border-radius: 12px; padding: 12px 14px; font-size: 14px; cursor: pointer;
      background: #1f6feb; color: #fff;
    }
    button.secondary { background: #2ea043; }
    button.orange { background: #f59e0b; color: #111; }
    button.ghost { background: #eef2f7; color: #111; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .muted { color: #667085; font-size: 13px; }
    .divider { height: 1px; background: #eef2f7; margin: 16px 0; }
    .center { display: grid; place-items: center; }

    /* Quiz */
    .question {
      font-family: "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic", "Meiryo", "Noto Sans JP", system-ui, sans-serif;
      font-size: 44px; font-weight: 700; letter-spacing: .5px; text-align: center; margin: 14px 0 6px;
    }
    .subquestion { text-align: center; font-size: 16px; margin-bottom: 6px; color: #333; }
    .meaning { text-align: center; font-size: 14px; color: #667085; margin-bottom: 14px; }
    .grid {
      display: grid; gap: 12px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
    @media (max-width: 520px) { .grid { grid-template-columns: 1fr; } }
    .choice {
      border: 1px solid #d7dbe0; border-radius: 12px; padding: 14px 12px;
      background: #fff; cursor: pointer; text-align: center;
      font-family: "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic", "Meiryo", "Noto Sans JP", system-ui, sans-serif;
      font-size: 20px; user-select: none;
    }
    .choice.disabled { cursor: not-allowed; opacity: .8; }
    .choice.correct { background: #16a34a; border-color: #16a34a; color: #fff; }
    .choice.wrong { background: #dc2626; border-color: #dc2626; color: #fff; }
    .feedback { text-align: center; font-size: 16px; margin: 10px 0 6px; min-height: 22px; }
    .feedback.ok { color: #16a34a; }
    .feedback.bad { color: #dc2626; }
    .feedback.warn { color: #f59e0b; }
    .meta { display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap; margin-top: 8px; color: #667085; font-size: 13px; }
    .countdown { text-align: center; font-size: 13px; color: #1f6feb; min-height: 18px; }

    /* Results list */
    .scrollbox {
      border: 1px solid #eef2f7; border-radius: 12px; background: #fff;
      max-height: 260px; overflow: auto; padding: 10px;
    }
    .wordline { font-size: 14px; padding: 6px 2px; border-bottom: 1px dashed #eef2f7; }
    .wordline:last-child { border-bottom: 0; }
    .buttons-row { display: flex; gap: 10px; flex-wrap: wrap; }
  </style>
</head>
<body>
  <div class="app">
    <div id="root" class="card"></div>
    <p class="muted" style="text-align:center;margin:14px 0 0;">
      Source: jlpt-vocab-api.vercel.app
    </p>
  </div>

<script>
(() => {
  const API_BASE = "https://jlpt-vocab-api.vercel.app";

  const state = {
    // settings
    jlptLevel: 5,
    numWords: 10,
    reviewMode: "multiple_choice", // or "typing"
    questionType: "furigana_to_kanji", // or "kanji_to_furigana"
    maxAttempts: 3,

    // session
    vocabulary: [],
    currentCards: [],
    currentIndex: 0,
    attempts: 0,
    questionSolved: false,
    countdownTimer: null,

    // scoring
    perfectFirstTry: 0,
    correctAfterRetry: 0,
    failedQuestions: 0,
    incorrectWords: [],
  };

  const el = (tag, attrs = {}, ...children) => {
    const node = document.createElement(tag);
    for (const [k, v] of Object.entries(attrs)) {
      if (k === "class") node.className = v;
      else if (k === "style") Object.assign(node.style, v);
      else if (k.startsWith("on") && typeof v === "function") node.addEventListener(k.slice(2).toLowerCase(), v);
      else if (v !== null && v !== undefined) node.setAttribute(k, String(v));
    }
    for (const c of children) {
      if (c === null || c === undefined) continue;
      node.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
    }
    return node;
  };

  const root = document.getElementById("root");

  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function sample(arr, n) {
    if (n >= arr.length) return shuffle(arr);
    const copy = arr.slice();
    const out = [];
    for (let i = 0; i < n; i++) {
      const idx = Math.floor(Math.random() * copy.length);
      out.push(copy.splice(idx, 1)[0]);
    }
    return out;
  }

  function normalizeApiWord(w) {
    // API commonly returns: { word, furigana, meaning, level, ... }
    let kanji = (w?.word ?? "").trim();
    let hira = (w?.furigana ?? "").trim();
    let meaning = (w?.meaning ?? "").trim();

    // handle kana-only entries
    if (!kanji && hira) kanji = hira;
    if (!hira && kanji) hira = kanji;

    return { furigana: hira, kanji, meaning };
  }

  async function fetchVocab(level, limit, offset = 0) {
    const url = new URL(API_BASE + "/api/words");
    url.searchParams.set("level", String(level));
    url.searchParams.set("limit", String(limit));
    url.searchParams.set("offset", String(offset));

    const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
    if (!resp.ok) throw new Error(`API request failed: ${resp.status} ${resp.statusText}`);
    const raw = await resp.json();

    const words = Array.isArray(raw) ? raw : (raw?.words ?? raw?.data ?? []);
    const vocab = words.map(normalizeApiWord).filter(v => v.furigana && v.kanji);
    return vocab;
  }

  function clearCountdown() {
    if (state.countdownTimer) {
      clearTimeout(state.countdownTimer);
      state.countdownTimer = null;
    }
  }

  function renderSetup() {
    clearCountdown();
    root.replaceChildren(
      el("h1", {}, "Japanese Flashcard Program"),
      el("div", { class: "divider" }),
      el("div", { class: "row" },
        el("label", {}, "JLPT Level:"),
        (() => {
          const sel = el("select", { id: "jlptLevel" },
            ...[5,4,3,2,1].map(n => el("option", { value: n, selected: n === state.jlptLevel ? "" : null }, `N${n}`))
          );
          sel.addEventListener("change", () => { state.jlptLevel = Number(sel.value); });
          return sel;
        })(),
        el("label", { style: { marginLeft: "10px" } }, "Number of words:"),
        (() => {
          const inp = el("input", { type: "number", min: "1", value: String(state.numWords), style: { width: "110px" }});
          inp.addEventListener("input", () => { state.numWords = Math.max(1, Number(inp.value || 1)); });
          return inp;
        })(),
      ),
      el("div", { class: "divider" }),

      el("h2", {}, "Review Mode"),
      el("div", { class: "radio-group" },
        radioPill("Multiple Choice", "reviewMode", "multiple_choice", state.reviewMode, v => state.reviewMode = v),
        radioPill("Typing Practice", "reviewMode", "typing", state.reviewMode, v => state.reviewMode = v),
      ),

      el("div", { class: "divider" }),

      el("h2", {}, "Question Type"),
      el("div", { class: "radio-group" },
        radioPill("Furigana → Kanji", "questionType", "furigana_to_kanji", state.questionType, v => state.questionType = v),
        radioPill("Kanji → Furigana", "questionType", "kanji_to_furigana", state.questionType, v => state.questionType = v),
      ),

      el("div", { class: "divider" }),

      el("div", { class: "row" },
        el("button", { class: "secondary", onclick: startReview }, "Start Review"),
        el("span", { class: "muted" }, "Loads a fresh word set each time.")
      )
    );
  }

  function radioPill(label, name, value, checkedValue, onChange) {
    const input = el("input", { type: "radio", name, value, ...(value === checkedValue ? { checked: "" } : {}) });
    input.addEventListener("change", () => onChange(value));
    const pill = el("label", { class: "radio-pill" }, input, el("span", {}, label));
    return pill;
  }

  async function startReview() {
    clearCountdown();

    const num = Math.max(1, Number(state.numWords || 1));
    const lvl = Number(state.jlptLevel);

    // show loading UI
    root.replaceChildren(
      el("h1", {}, "Loading..."),
      el("p", { class: "muted" }, "Fetching vocabulary from the API.")
    );

    try {
      const fetchLimit = Math.max(num, 40); // extra for distractors
      const vocab = await fetchVocab(lvl, fetchLimit, 0);
      if (!vocab.length) throw new Error("API returned no words for that level.");

      if (num > vocab.length) {
        throw new Error(`Only ${vocab.length} words available from API right now.`);
      }

      state.vocabulary = vocab;
      state.currentCards = sample(vocab, num);
      state.currentIndex = 0;

      // reset scoring
      state.attempts = 0;
      state.questionSolved = false;
      state.perfectFirstTry = 0;
      state.correctAfterRetry = 0;
      state.failedQuestions = 0;
      state.incorrectWords = [];

      renderFlashcard();
    } catch (err) {
      root.replaceChildren(
        el("h1", {}, "API Error"),
        el("p", {}, String(err?.message || err)),
        el("div", { class: "buttons-row" },
          el("button", { class: "ghost", onclick: renderSetup }, "Back"),
          el("button", { class: "secondary", onclick: startReview }, "Retry")
        )
      );
    }
  }

  function getAnswerChoices(correctAnswer, answerType) {
    const choices = [correctAnswer];
    const otherItems = [];
    for (const item of state.vocabulary) {
      const v = item[answerType];
      if (v && v !== correctAnswer) otherItems.push(v);
    }
    // unique
    const unique = Array.from(new Set(otherItems));
    let distractors;
    if (unique.length >= 3) {
      distractors = sample(unique, 3);
    } else {
      distractors = unique.slice();
      while (distractors.length < 3) distractors.push("---");
    }
    return shuffle(choices.concat(distractors));
  }

  function renderFlashcard() {
    clearCountdown();

    if (state.currentIndex >= state.currentCards.length) {
      renderResults();
      return;
    }

    const card = state.currentCards[state.currentIndex];
    state.attempts = 0;
    state.questionSolved = false;

    const isH2K = state.questionType === "furigana_to_kanji";
    const questionText = isH2K ? card.furigana : card.kanji;
    const correctAnswer = isH2K ? card.kanji : card.furigana;
    const answerType = isH2K ? "kanji" : "furigana";

    const feedback = el("div", { class: "feedback", id: "feedback" }, "");
    const attemptsLabel = el("div", { class: "muted", id: "attempts" }, `Attempts: ${state.attempts}/${state.maxAttempts}`);
    const countdown = el("div", { class: "countdown", id: "countdown" }, "");

    const header = el("div", {},
      el("div", { class: "subquestion" }, isH2K ? "Furigana:" : "Kanji:"),
      el("div", { class: "question" }, questionText),
      el("div", { class: "meaning" }, `Meaning: ${card.meaning || ""}`),
      feedback,
      attemptsLabel,
      countdown,
      el("div", { class: "meta" },
        el("div", {}, `Card ${state.currentIndex + 1} of ${state.currentCards.length}`),
        el("div", {}, `Mode: ${state.reviewMode === "multiple_choice" ? "Multiple Choice" : "Typing"} • N${state.jlptLevel}`)
      )
    );

    let body;
    if (state.reviewMode === "multiple_choice") {
      const choices = getAnswerChoices(correctAnswer, answerType);
      const grid = el("div", { class: "grid", id: "grid" },
        ...choices.map(choice => el("div", {
          class: "choice",
          onclick: () => checkMultipleChoice(choice, correctAnswer)
        }, choice))
      );
      body = grid;
    } else {
      const inp = el("input", { type: "text", id: "answerInput", placeholder: "Type your answer…" });
      const submit = el("button", { onclick: () => checkTyping(correctAnswer) }, "Submit Answer");
      const wrap = el("div", { class: "center", style: { gap: "12px" } },
        inp,
        submit,
        el("div", { class: "muted", style: { marginTop: "8px", textAlign: "center" } },
          "Tip: Use a Japanese IME for kana/kanji input if needed."
        )
      );

      // enter key submit
      setTimeout(() => {
        inp.focus();
        inp.addEventListener("keydown", (e) => {
          if (e.key === "Enter") checkTyping(correctAnswer);
        });
      }, 0);

      body = wrap;
    }

    root.replaceChildren(
      el("h1", {}, "Japanese Flashcard Program"),
      el("div", { class: "divider" }),
      header,
      el("div", { class: "divider" }),
      body,
      el("div", { class: "divider" }),
      el("div", { class: "buttons-row" },
        el("button", { class: "ghost", onclick: renderSetup }, "Back to Setup"),
      )
    );
  }

  function lockChoices() {
    const nodes = root.querySelectorAll(".choice");
    nodes.forEach(n => {
      n.classList.add("disabled");
      n.style.pointerEvents = "none";
    });
  }

  function highlightChoices(selected, correct) {
    const nodes = Array.from(root.querySelectorAll(".choice"));
    for (const n of nodes) {
      const txt = n.textContent;
      if (txt === correct) n.classList.add("correct");
      if (txt === selected && selected !== correct) n.classList.add("wrong");
    }
  }

  function autoNextCard(countdownSeconds = 3) {
    const cd = root.querySelector("#countdown");
    if (!cd) return;

    function tick(sec) {
      if (sec > 0) {
        cd.textContent = `Next card in ${sec}…`;
        state.countdownTimer = setTimeout(() => tick(sec - 1), 500);
      } else {
        cd.textContent = "";
        state.currentIndex += 1;
        renderFlashcard();
      }
    }
    tick(countdownSeconds);
  }

  function checkMultipleChoice(selected, correct) {
    if (state.questionSolved) return;

    state.attempts += 1;
    const attemptsLabel = root.querySelector("#attempts");
    if (attemptsLabel) attemptsLabel.textContent = `Attempts: ${state.attempts}/${state.maxAttempts}`;

    const feedback = root.querySelector("#feedback");

    if (selected === correct) {
      if (feedback) {
        feedback.textContent = "✓ Correct!";
        feedback.className = "feedback ok";
      }

      highlightChoices(selected, correct);
      lockChoices();

      if (state.attempts === 1) state.perfectFirstTry += 1;
      else state.correctAfterRetry += 1;

      state.questionSolved = true;
      autoNextCard(3);
      return;
    }

    // incorrect
    if (feedback) {
      feedback.textContent = "✗ Incorrect!";
      feedback.className = "feedback bad";
    }

    // disable only selected choice (like your Tk version)
    const nodes = Array.from(root.querySelectorAll(".choice"));
    for (const n of nodes) {
      if (n.textContent === selected) {
        n.classList.add("wrong", "disabled");
        n.style.pointerEvents = "none";
      }
    }

    // if max attempts reached
    if (state.attempts >= state.maxAttempts) {
      if (feedback) {
        feedback.textContent = `✗ The correct answer is: ${correct}`;
        feedback.className = "feedback warn";
      }

      highlightChoices(selected, correct);
      lockChoices();

      const card = state.currentCards[state.currentIndex];
      const entry = `${card.furigana} (${card.kanji}) - ${card.meaning || ""}`;
      if (!state.incorrectWords.includes(entry)) state.incorrectWords.push(entry);

      state.failedQuestions += 1;
      state.questionSolved = true;
      autoNextCard(3);
    }
  }

  function checkTyping(correct) {
    if (state.reviewMode !== "typing" || state.questionSolved) return;

    const inp = root.querySelector("#answerInput");
    if (!inp) return;

    const user = (inp.value || "").trim();
    if (!user) return;

    state.attempts += 1;
    const attemptsLabel = root.querySelector("#attempts");
    if (attemptsLabel) attemptsLabel.textContent = `Attempts: ${state.attempts}/${state.maxAttempts}`;

    const feedback = root.querySelector("#feedback");

    if (user === correct) {
      if (feedback) {
        feedback.textContent = "✓ Correct!";
        feedback.className = "feedback ok";
      }
      inp.style.background = "#dcfce7";
      inp.style.borderColor = "#16a34a";
      inp.disabled = true;

      if (state.attempts === 1) state.perfectFirstTry += 1;
      else state.correctAfterRetry += 1;

      state.questionSolved = true;
      autoNextCard(3);
      return;
    }

    // incorrect
    if (feedback) {
      feedback.textContent = "✗ Incorrect!";
      feedback.className = "feedback bad";
    }
    inp.style.background = "#fee2e2";
    inp.style.borderColor = "#dc2626";
    inp.value = "";

    if (state.attempts >= state.maxAttempts) {
      if (feedback) {
        feedback.textContent = `✗ The correct answer is: ${correct}`;
        feedback.className = "feedback warn";
      }
      inp.disabled = true;
      inp.value = correct;
      inp.style.background = "#fef3c7";
      inp.style.borderColor = "#f59e0b";

      const card = state.currentCards[state.currentIndex];
      const entry = `${card.furigana} (${card.kanji}) - ${card.meaning || ""}`;
      if (!state.incorrectWords.includes(entry)) state.incorrectWords.push(entry);

      state.failedQuestions += 1;
      state.questionSolved = true;
      autoNextCard(3);
    }
  }

  function renderResults() {
    clearCountdown();

    const total = state.currentCards.length;
    const correct = state.perfectFirstTry + state.correctAfterRetry;
    const accuracy = total ? (correct / total) * 100 : 0;
    const firstTryAccuracy = total ? (state.perfectFirstTry / total) * 100 : 0;

    const details = el("div", {},
      el("div", { class: "muted" }, `• Perfect (1st try): ${state.perfectFirstTry}`),
      el("div", { class: "muted" }, `• Correct after retry: ${state.correctAfterRetry}`),
      el("div", { class: "muted" }, `• Failed: ${state.failedQuestions}`),
      el("div", { class: "muted", style: { marginTop: "8px" } }, `First Try Accuracy: ${firstTryAccuracy.toFixed(1)}%`),
      el("div", { class: "muted" }, `Mode: ${state.reviewMode === "multiple_choice" ? "Multiple Choice" : "Typing"} | Question Type: ${state.questionType.replaceAll("_", " ")}`),
    );

    let listSection;
    if (state.incorrectWords.length) {
      listSection = el("div", {},
        el("h2", {}, "Words to review"),
        el("div", { class: "scrollbox" },
          ...state.incorrectWords.map((w, i) => el("div", { class: "wordline" }, `${i + 1}. ${w}`))
        )
      );
    } else {
      listSection = el("div", { class: "center" },
        el("h2", {}, "Perfect score!"),
        el("p", { class: "muted" }, "All answers correct.")
      );
    }

    root.replaceChildren(
      el("h1", {}, "Review Complete!"),
      el("div", { class: "divider" }),
      el("div", {},
        el("div", { style: { fontSize: "18px", fontWeight: "700" } },
          `Final Score: ${accuracy.toFixed(1)}% (${correct}/${total})`
        ),
        el("div", { style: { marginTop: "10px" } }, details)
      ),
      el("div", { class: "divider" }),
      listSection,
      el("div", { class: "divider" }),
      el("div", { class: "buttons-row" },
        el("button", { class: "secondary", onclick: renderSetup }, "Restart Program"),
        // el("button", { class: "orange", onclick: renderSetup }, "Try Different Mode"),
      )
    );
  }

  // init
  renderSetup();
})();
</script>
</body>
</html>
